import {Widget} from '@phosphor/widgets';

import {ICodeCellModel} from '@jupyterlab/cells';

import {IOutsourceFactoryOptions} from '@deathbeds/jupyterlab-outsource';

import Blockly, {IWorkspace} from 'node-blockly/browser';

import {CSS, PLUGIN_ID, IBlocklyMetadata} from '.';

// tslint:disable
const DEFAULT_TOOLBOX = require('!!raw-loader!../xml/toolbox.xml') as string;
// tslint:enable

export class BlocklySource extends Widget {
  private _cellModel: ICodeCellModel;
  private _wrapper: HTMLDivElement;
  private _workspace: IWorkspace;
  private _lastXml: string;

  constructor(options: IOutsourceFactoryOptions) {
    super();
    this.addClass(CSS.OUTER_WRAPPER);
    this._cellModel = options.model as ICodeCellModel;
    this._cellModel.metadata.changed.connect(this._metadataChanged, this);

    this.node.appendChild((this._wrapper = document.createElement('div')));
    this._wrapper.className = CSS.WRAPPER;
    setTimeout(() => {
      this._workspace = Blockly.inject(this._wrapper, {
        toolbox: this.metadata.toolbox || DEFAULT_TOOLBOX,
      });
      this._metadataToWorkspace();
      this._workspace.addChangeListener(() => this._workspaceChanged());
    }, 1);
  }

  private _metadataToWorkspace() {
    const xml = this.metadata.workspace;
    if (!xml) {
      return;
    }
    let parser = new DOMParser();
    let dom = parser
      .parseFromString(xml as string, 'application/xml')
      .querySelector('xml');
    Blockly.Xml.domToWorkspace(dom, this._workspace);
  }

  dispose() {
    super.dispose();
    this._cellModel.metadata.changed.disconnect(this._metadataChanged, this);
  }

  onResize() {
    if (!this._workspace) {
      return;
    }
    Blockly.svgResize(this._workspace);
  }

  private _workspaceChanged() {
    const meta = this.metadata;
    const xml = Blockly.Xml.domToText(
      Blockly.Xml.workspaceToDom(this._workspace)
    ).trim();
    if (xml === this._lastXml) {
      return;
    }
    this._lastXml = xml;

    this.metadata = {
      ...meta,
      workspace: xml,
    };
  }

  get metadata(): IBlocklyMetadata {
    return (this._cellModel.metadata.get(PLUGIN_ID) as IBlocklyMetadata) || {};
  }

  set metadata(metadata: IBlocklyMetadata) {
    this._cellModel.metadata.set(PLUGIN_ID, metadata as any);
  }

  private _metadataChanged() {
    const oldSource = this._cellModel.value.text;
    let source = Blockly.Python.workspaceToCode(this._workspace)
      .trim()
      .replace(/  /g, '    ');

    source = `# generated by blockly\n\n${source}`;

    if (oldSource !== source) {
      this._cellModel.value.text = source;
    }
  }
}
